        // for bools, 1 = true, 0 = false
        // version;         //  number - the version of the movie file format, for now always 3
        // emuVersion;      //  number - the version of the emulator used to produce the movie
        // rerecordCount;   // ?number - the rerecord count
        // palFlag;         // ?bool   - true if the movie uses PAL timing
        // NewPPU;          // ?bool   - true if the movie uses New PPU (what's that?)
        // FDS;             // ?bool   - true if the movie was recorded on a Famicom Disk System game
        // fourscore;       //  bool   - true if a fourscore was used; if not, port0 and port1 are required
        // port0;           //  number - SI_NONE = 0, SI_GAMEPAD = 1, SI_ZAPPER = 2
        // port1;           //  " "      " "
        // port2;           //  number - indicates the type of the FCExp port device attached (always 0?)
        // binary;          // ?bool   - if true, input log is in binary format
        // length;          // ?number - number of frames in the input log
        // romFilename;     //  string - the name of the file used to record the movie
        // comment;         // ?string - a memo - there are various conventions that we won't worry about yet
        // subtitle;        // ?string - a subtitle - there are various conventions that we won't worry about yet
        // guid;            //  string - the movie's GUID, used to ensure savestates belong to the current movie
        // romChecksum;     //  string - the base64 of the hexified MD5 hash of the ROM used to record the movie
        // savestate;       // ?string - a fcs savestate blob, in case a movie was recorded from savestate rather than power on

// type converters
const num  = a => +a;
const bool = a => !!+a;
const str  = a => a;  

// - = we ignore this for now but could use it; + = we use this; space = we probably don't need to do anything with this (TODO)
const PROPS = [
    {fieldName: 'version',       fieldType: num,  fieldRequired: true } // the version of the movie file format, for now always 3
,   {fieldName: 'emuVersion',    fieldType: num,  fieldRequired: true } // the version of the emulator used to produce the movie
,   {fieldName: 'rerecordCount', fieldType: num,  fieldRequired: false} // the rerecord count
,   {fieldName: 'palFlag',       fieldType: bool, fieldRequired: false} //-true if the movie uses PAL timing
,   {fieldName: 'NewPPU',        fieldType: bool, fieldRequired: false} //-true if the movie uses New PPU (what's that?)
,   {fieldName: 'FDS',           fieldType: bool, fieldRequired: false} //-true if the movie was recorded on a Famicom Disk System game
,   {fieldName: 'fourscore',     fieldType: bool, fieldRequired: true } //-true if a fourscore was used; if not, port0 and port1 are required
,   {fieldName: 'port0',         fieldType: num,  fieldRequired: true } //-indicates the device attached to the first port: (see below)
,   {fieldName: 'port1',         fieldType: num,  fieldRequired: true } //-" second port:    SI_NONE = 0, SI_GAMEPAD = 1, SI_ZAPPER = 2
,   {fieldName: 'port2',         fieldType: num,  fieldRequired: true } // indicates the type of FCExp (?) port device attached: SIFC_NONE = 0 (always 0?)
,   {fieldName: 'binary',        fieldType: bool, fieldRequired: false} //+true if input log is stored in binary format
,   {fieldName: 'length',        fieldType: num,  fieldRequired: false} //-movie size - number of frames in input log. used in fm3 to allow data at end
,   {fieldName: 'romFilename',   fieldType: str,  fieldRequired: true } //-the name of the ROM file used to record the movie
,   {fieldName: 'comment',       fieldType: str,  fieldRequired: false} //-a memo of some sort which we can ignore for the time being
,   {fieldName: 'subtitle',      fieldType: str,  fieldRequired: false} //-movie subtitles which we can ignore for the time being
,   {fieldName: 'guid',          fieldType: str,  fieldRequired: true } // a unique identifier for a movie, generated when the movie is created
,   {fieldName: 'romChecksum',   fieldType: str,  fieldRequired: true } //-see the spec. generated by some bizarre mechanism which I can't replicate
,   {fieldName: 'savestate',     fieldType: str,  fieldRequired: false} //-a FCS savestate blob if a movie was recorded from savestate
];

/*128 64 32 16 8 4 2 1  Button | Status
    |  |  |  | | | | \- A      | Soft Reset
    |  |  |  | | | \--- B      | Hard Reset (Power)
    |  |  |  | | \----- Select | FDS Disk Insert
    |  |  |  | \------- sTart  | FDS Disk Select
    |  |  |  \--------- Up     | VS Insert Coin
    |  |  \------------ Down   | 
    |  \--------------- Left   |
    \------------------ Right  |                  */

function FM2(rawData, overseer, debug = false) {
    // --------------------------------------
    // -- THINGS WE NEED FROM THE OVERSEER --
    // --------------------------------------
    const _buttonDown = overseer.buttonDown.bind(overseer);
    const _buttonUp = overseer.buttonUp.bind(overseer);
    const BUTTONS = overseer.BUTTONS;

    // -------------------------------------
    // -- PROPERTY PARSE HELPER FUNCTIONS --
    // -------------------------------------
    var pos = 0, line = 1, col = 0;
    function next() {
        var chr = rawData.charAt(pos++);
        if (chr === '\n') line++, col=0; else col++;
        return chr;
    }
    function peek() { return rawData.charAt(pos); }
    function eof()  { return peek() === ''; }
    function err(msg) { throw new Error(`${msg} (${line}:${col})`); }
    function newline() { return col === 0; }

    var lastFrameWasEOF = false; 

    this.eof = eof; // export

    function parseField() {
        if (!newline()) err('Can\'t try to parse field in the middle of a line!');
        var fieldName = '', fieldValue = '';
        while (peek() !== ' ')  fieldName  += next();
        next(); // consume space
        while (peek() !== '\n') fieldValue += next();
        next(); // consume newline
        var res = {};
        res[fieldName] = fieldValue;
        return res;
    }

    function freezeState() { return {pos: pos, line: line, col: col}; }

    // --------------------------
    // -- PARSE FM2 PROPERTIES --
    // --------------------------
    var parsedProps = {};

    // TODO: this is very slow for playing movies with lots of comments/subtitles
    while (peek() !== '|') Object.assign(parsedProps, parseField());
    this.props = {};
    for (let prop of PROPS) {
        if (parsedProps.hasOwnProperty(prop.fieldName)) {
            this.props[prop.fieldName] = prop.fieldType(parsedProps[prop.fieldName]);
        } else {
            if (prop.fieldRequired) throw new Error(`Required prop ${prop.fieldName} not found in movie`);
        }
    }

    const PORT_INPUT_LENGTH = {0: 0, 1: 1, 2: 12};

    if (this.props.binary) next(); // in text mode the initial pipe is structural; in binary mode it's just a separator

    // -------------------------
    // -- PARSE FM2 INPUT LOG --
    // -------------------------
    const movieStartState = freezeState();
    this.frameCount = 0;

    const DEBUG_KEYMAP = {};
    DEBUG_KEYMAP[BUTTONS.RIGHT]  = 'R';
    DEBUG_KEYMAP[BUTTONS.LEFT]   = 'L';
    DEBUG_KEYMAP[BUTTONS.DOWN]   = 'D';
    DEBUG_KEYMAP[BUTTONS.UP]     = 'U';
    DEBUG_KEYMAP[BUTTONS.START]  = 'T';
    DEBUG_KEYMAP[BUTTONS.SELECT] = 'S';
    DEBUG_KEYMAP[BUTTONS.B]      = 'B';
    DEBUG_KEYMAP[BUTTONS.A]      = 'A';
    var debug_line_log = '';


    function buttonDown(port, button) {
        if (debug) debug_line_log += DEBUG_KEYMAP[button];
        _buttonDown(port, button);
    }
    function buttonUp(port, button) { 
        if (debug) debug_line_log += '.';
        _buttonUp(port, button);
    }
    const BIN_DO = {false: buttonUp, true: buttonDown};

    function handleEOF() { // release all buttons
        // without this it's one frame off. no idea why, easier to add a hack than investigate. should work
        if (!lastFrameWasEOF) { lastFrameWasEOF = true; return; }
        console.log('howdy from fm2! handling eof')
        for (let [k, v] of Object.entries(BUTTONS)) {
            _buttonUp(1, v); // TODO will need to change this for multiport support
        }
    }

    function nextBinaryFrame(nes) {
        if (debug) debug_line_log = '';
        if (eof()) { handleEOF(); return; }
        if (this.frameCount < 0) {
            this.frameCount++; return;
        }

        // just discard the command byte for now
        const commandByte = next();

        // we currently assume there's only one player
        const byte = next().charCodeAt(0);

        BIN_DO[!!(byte & 128)](1, BUTTONS.RIGHT);
        BIN_DO[!!(byte & 64) ](1, BUTTONS.LEFT);
        BIN_DO[!!(byte & 32) ](1, BUTTONS.DOWN);
        BIN_DO[!!(byte & 16) ](1, BUTTONS.UP);
        BIN_DO[!!(byte & 8)  ](1, BUTTONS.START);
        BIN_DO[!!(byte & 4)  ](1, BUTTONS.SELECT);
        BIN_DO[!!(byte & 2)  ](1, BUTTONS.B);
        BIN_DO[!!(byte & 1)  ](1, BUTTONS.A);

        if (debug) console.log(debug_line_log, this.frameCount);
        this.frameCount++;
    }
    const UNPRESSED = new Set([' ', '.']);
    function isPressed(button) { return !(UNPRESSED.has(button)); }
    function nextTextFrame(nes) {
        if (debug) debug_line_log = '';
        if (eof()) { handleEOF(); return; }
        if (this.frameCount < 0) {
            this.frameCount++; return;
        }

        next(); // discard initial pipe
        const commandByte = next(); // the command handling is the same as in binary mode
        next(); // discard this pipe too

        // currently we assume one player with a gamepad (TODO)
        BIN_DO[isPressed(next())](1, BUTTONS.RIGHT);
        BIN_DO[isPressed(next())](1, BUTTONS.LEFT);
        BIN_DO[isPressed(next())](1, BUTTONS.DOWN);
        BIN_DO[isPressed(next())](1, BUTTONS.UP);
        BIN_DO[isPressed(next())](1, BUTTONS.START);
        BIN_DO[isPressed(next())](1, BUTTONS.SELECT);
        BIN_DO[isPressed(next())](1, BUTTONS.B);
        BIN_DO[isPressed(next())](1, BUTTONS.A);

        // *only* one player, so toss the rest of the line (TODO)
        while (peek() !== '\n') next();
        next(); // discard newline

        if (debug) console.log(debug_line_log, this.frameCount);
        this.frameCount++;
    }

    this.nextFrame = (this.props.binary) ? nextBinaryFrame.bind(this) : nextTextFrame.bind(this);

    function setState(state) {
        pos = state.pos;
        line = state.line;
        col = state.col;
    }
    this.reset = () => setState(movieStartState);
}